# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```

# Архитектура 

В основе архитектуры моего веб-приложения лежит паттерн MVP (Model-View-Presenter). Он позволяет разделить ответственность между слоями и облегчает масштабирование, сопровождение и тестирование приложения. Архитектура разделена на три ключевых компонента:

Model — слой бизнес-логики и работы с данными. Отвечает за получение, хранение и обновление данных, а также за взаимодействие с внешними API или локальным хранилищем.

View — слой пользовательского интерфейса. Представляет данные пользователю и генерирует события на действия (например, клики, ввод данных). View не содержит бизнес-логики и не взаимодействует напрямую с моделью.

Presenter — посредник между View и Model. Получает события от View, обрабатывает их, вызывает соответствующие методы модели и обновляет View в зависимости от результата.

Взаимодействие между компонентами осуществляется следующим образом: `View <---> Presenter <--> Model`. Такой подход помогает четко разграничить ответственность каждого слоя и минимизировать связность между компонентами.


Ключевой особенностью реализации является использование событийно-ориентированного подхода с применением класса EventEmitter. Каждый компонент — Model, View, Presenter — обменивается сообщениями через события, а не через прямые вызовы. Это позволяет:

* реализовать слабую связность между слоями;

* упростить масштабирование (например, подключение новых страниц, форм, модулей);

* повысить читаемость и тестируемость кода.

Каждый компонент может самостоятельно вызывать события (emit) и реагировать на них (on), при этом оставаясь независимым от конкретной реализации других частей приложения.

В моём проекте роль Presenter выполняет модуль index.ts, в котором:
создаются экземпляры всех основных компонентов (модель, представление и др.);
настраиваются подписки на события от View и Model;
реализуется логика, связывающая пользовательские действия с обновлением данных и интерфейса.

## Базовый код

#### Класс EventEmitter
Брокер событий позволяет отправлять события и подписываться на события, происходящие в системе. Класс используется в презентере для обработки событий и в слоях приложения для генерации событий.  
Основные методы, реализуемые классом описаны интерфейсом `IEvents`:
- `on` - подписка на событие
- `emit` - инициализация события
- `trigger` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие.  

#### Класс Api 
описывает базовый класс для работы с HTTP запросами:
* `get(uri: string)` - выполняет GET-запрос по указанному пути.
* `post(uri: string, data: object, method: ApiPostMethods = 'POST')` - выполняет POST (или PUT/PATCH) запрос с телом.

##  Основные сущности, интерфейсы и классы

### Model (слой данных) 

#### Класс ShopModel 
описывает структуру модели магазина в веб-приложении. Он объединяет состояние и методы для работы с каталогом товаров, корзиной и оформлением заказа:

Поля класса:
* `_catalog: IProduct[]` - массив товаров в магазине.
* `_basket: IProduct[]` - массив товаров, добавленных в корзину.
* `_preview: IProduct | null` - выбранный товар для предварительного просмотра.
* `order: IOrder | null` - данные текущего заказа.

Методы класса:

* `setCatalog(catalog:  IProduct[]): void` - установить (обновить) список товаров в каталоге.
* `setBasket(basket:  IProduct[]): void` - установить (обновить) список товаров в корзине.
* `getProduct(id: TProductId): IProduct` - получить товар по его id.
* `addBasket(product: IProduct): void` - добавить товар в корзину.
* `removeBasket(product: IProduct): void` - удалить товар из корзины.
* `clearBasket():void` - очистить корзину.
* `getBasketLength(): number` - количество товаров в корзине.
* `getBasketTotalPrice(): number` - общая стоимость товаров в корзине. 
* `setPreview(product: IProduct): void` - установить товар для предварительного просмотра.
* `checkValidate(data: Record<keyof IOrder,string | number>): boolean` - проверка корректности введённых данных заказа.
* Сеттеры и геттеры для сохранения и получения данных из полей класса


#### Класс ShopApi 
расширяет базовый Api. Он представляет собой специализированный data layer (часть Model в архитектуре MVP), ответственную за взаимодействие с сервером

Конструктор:  
принимает и передает в родительский конструктор Api поля baseUrl и options

Поля класса:
* `getProductList(): Promise<IProductList>` - метод получения списка товаров с сервера

* `orderProduct()Promise<IOrderSuccess>` - метод отправки данных заказа на сервер

### View (слой представления) 

#### Класс Page
Отвечает за отображение товаров на главной странице 

Поля класса:
* `container: HTMLElement` - контейнер галереи товаров.
* `basketButton: HTMLButtonElement` - кнопка корзины.
* `counter: HTMLElement` — счетчика товаров в корзине.
 
 Методы: 
 * `setGallery(products: IProduct[]): void` - отображает массив карточек товаров
 * `setCounter(count: number): void` - обновляет счётчик товаров


#### Класс Card
Отвечает за создание карточки товара. В конструктор класса передается template: HTMLTemplateElement. 

Методы:

* `renderGallery(product: IProduct): HTMLElement` - создаёт карточку товара для галереи.
* `renderPreview(product: IProduct): HTMLElement` - создаёт карточку товара для предпросмотра.
* `renderBasket(product: IBasket): HTMLElement` - создаёт карточку товара для корзины.

#### Класс Modal
Реализует модальное окно. Универсальный контейнер модального окна (id="modal-container"). Так же предоставляет методы `open`, `close`, `render` для управления отображением модального окна. Устанавливает слушатели на клавиатуру, для закрытия модального окна по Esc, на клик в оверлей и кнопку-крестик для закрытия попапа.  
* `constructor(selector: string, events: IEvents)` Конструктор принимает селектор, по которому в разметке страницы будет идентифицировано модальное окно и экземпляр класса `EventEmitter` для возможности инициации событий.

Поля класса:
* `modal: HTMLElement` - элемент модального окна
* `events: IEvents` - брокер событий

#### Класс BasketView 
Отображает корзину. Для кнопки "Оформить" в классе устанавливается обработчик клика, в результате работы которого должна открываться первая форма для оформления заказа, являющаяся полем класса `OrderForm`.

Поля:
* `_container: HTMLElement` - контейнер корзины
* `_itemsContainer: HTMLElement` - контейнер для списка товаров.
* `_total: HTMLElement` - элемент для отображения суммы.
* `_orderButton: HTMLButtonElement` - кнопка оформления заказа.

Методы:

* `setClickHandler(handler: () => void): void` - устанавливает обработчик нажатия кнопки.
* `setValid(isValid: boolean): void` - изменяет активность кнопки оформления заказа.

#### Класс OrderForm
Форма выбора способа оплаты и адреса доставки. Для кнопки "далее" в классе устанавливается обработчик клика, в результате работы которого должна открываться вторая форма для оформления заказа, являющаяся полем класса `ContactForm`.

Поля:

* `_form: HTMLFormElement` - элемент формы.
* `_OnlinePaymentButton: HTMLElement` - кнопка онлайн оплаты.
* `_OfflinePaymentButton: HTMLElement` - кнопка оффлайн оплаты.
* `_addressInput: HTMLElement` - поле для адреса.
* `_Button: HTMLButtonElement` - отправка формы.

Методы:
* `getData(): TOrderInfo` - возвращает введенные данные.
* `setValid(isValid: boolean): void` - изменяет активность кнопки отправки формы.
* `setSubmitHandler(handler: () => void): void` - устанавливает обработчик отправки формы.
* `resetForm(): void` - очищает форму.

#### Класс ContactForm
Форма ввода контактных данных. Для кнопки "Оплатить" в классе устанавливается обработчик клика, в результате работы которого должен отправляться запрос на сервер. При успешном запросе должен отрисовываться контент класса `Success`

Поля:

* `_form: HTMLFormElement` - элемент формы.
* `_emailInput: HTMLElement` - поле для email.
* `_phoneInput: HTMLElement` - поле для телефона.
* `_Button: HTMLButtonElement` - отправка формы.

Методы:

* `getData(): TOrderInfo` - возвращает введенные данные.
* `setValid(isValid: boolean): void` - изменяет активность кнопки отправки формы.
* `setSubmitHandler(handler: () => void): void` - устанавливает обработчик отправки формы.
* `resetForm(): void` - очищает форму.

#### Класс Success
Отображает сообщение об успешном оформлении заказа

Поля:
* `_container: HTMLElement` - контейнер сообщения.
* `_total: HTMLElement` - элемент для отображения суммы.
* `_Button: HTMLButtonElement` - кнопка успешного оформления заказа.

Методы:

* `showTotal(total: number): void` - отображает сумму заказа.
* `setCloseHandler(handler: () => void): void` - устанавливает обработчик закрытия.

## Взаимодействие компонентов

В приложении происходит в результате действия пользователя встроенное браузерное событие -> В обработчике этого события, который является методом класса слоя представления, вызывается обработчик генерируемого события через метод-посредник emit. Этот обработчик вызывает метод класса модели данных для алгоритмической обработки встроенного события -> Подготовленные в методе класса модели в результате этой обработки данные  через метод посредника emit передаются классу представления для их отображения.
То есть, в терминах MVP каждую цепочку действий в проекте можно описать следующей цепочкой:
`V --> P --> M --> P --> V`, где
* `V` - означает класс слоя View,
* `P` - означает метод презентера Present
* `M` - означает класс слоя Model, 
--> означает переход выполнения приложения из одной сущности в другую.

Взаимодействие между компонентами реализовано в файле `index.ts` — он выступает в роли точки входа приложения и выполняет функции презентера (Presenter).
Взаимодействие осуществляется за счет событий генерируемых с помощью брокера событий и обработчиков этих событий, описанных в `index.ts`\
В `index.ts` сначала создаются экземпляры всех необходимых классов, а затем настраивается обработка событий.

#### События 

* `catalog:loaded` - загружен каталог товаров.
* `catalog:preview` - клик по товару для открытия предпросмотра.
* `basket:changed` - изменены данные корзины.
* `basket:add` - добавлен товар в корзину.
* `basket:remove` - удален товар из корзины.
* `order:submit` - заказ оформлен.
* `order:address` - указан адрес и способ оплаты товара.
* `order:contact` - указаны контактные данные покупателя.
* `order:success` - заказ успешно оформлен.
* `product:select` - выбрана карточка.


## Данные и типы данных, используемые в приложении

`IProduct`  - описывает структуру объекта товара: 
  * `id: TProductId` - идентификатор, простой тип на основе string.
  * `description: string` - подробное описание товара.
  * `image: string` - ссылка на изображение.
  * `title: string` - название товара.
  * `category: string` - категория, к которой относится товар.
  * `price: number | null` -  цена товара. Может быть null, если цена не указана или временно недоступна.  


`IProductList` - описывает структуру ответа или набора данных каталога товаров. Используется для отображения и обработки результатов загрузки списка товаров:
  * `total: number` - общее количество товаров в каталоге или текущем запросе.
  * `items: IProduct[]` -  массив объектов товаров, соответствующих интерфейсу IProduct.
  * `preview: string | null` - дополнительная строка-превью (например, описание раздела, подсказка, заголовок, рекламный текст). Может быть null, если превью отсутствует.

`IClient` - описывает базовые данные клиента:
  * `email: string` - электронная почта.
  * `phone: string` - номер телефона.
  * `address: string` - адрес доставки.

`IOrderForm` - расширяет `IClient` и добавляет поля, необходимые при отправке формы заказа:
  * `payment: TPaymentType` - способ оплаты, простой тип основанный строкой `'Online'` или `'Offline'`.
  * `total: number` - итоговая сумма заказа.

`IOrder` - расширяет `IOrderForm`  и представляет собой полную структуру данных, которая используется для оформления и отправки заказа. Он включает:
  * `items: TProductId[]` - массив идентификаторов товаров, добавленных в заказ.


`IOrderSuccess` - описывает успешный ответ при оформлении заказа:
  * `id: string` - ID заказа, который можно использовать для отслеживания или подтверждения.  
  * `total: number`- итоговая сумма, рассчитанная и подтверждённая сервером.

`IBasket` - расширяет IProduct для отображения индекса товара в корзине.
  * `index: number` - позиция товара в списке корзины, используется для упорядочивания.           

`TOrderInfo` - описывает шаг оформления доставки и выбора оплаты в заказе:
* `payment: TPaymentType` - способ оплаты, простой тип основанный строкой `'Online'` или `'Offline'`.
* `address: string` - адрес доставки.

`TOrderContact` - описывает контактную информацию покупателя:
* `email: string` - электронная почта.
* `phone: string` - номер телефона.